Note that the "⊢" used in a rule means something slightly different from when used to state theorems.
There is no ambiguity because for theorem statements "S ⊢ Q" has a system S, whereas for rules "X;...;Y ⊢ Z;...;W" the stuff on the left are either statements or conditions or proof structure.
Precedence rules:
	The standard precedence rules are (highest to lowest): [infix operations],[relations including =],¬,∧,∨,{⇒,⇔}
Symbol-defining rule:
	For many-sorted FOL, you can define a restricted function-symbol (i.e. with specified input/output types):
		∀x[1]∈S[1] ... ∀x[k]∈S[k] ∃!y∈T ( Q(x[1],...,x[k],y) ) ⊢ ∀x[1]∈S[1] ... ∀x[k]∈S[k] ∀y∈T ( f(x[1],...,x[k]) = y ⇔ Q(x[1],...,x[k],y) ). [where f is a fresh function-symbol]
Syntax:
	Syntax rules:
			Notation:
				( Given x∈S ⊢ A : bool ) ⊢ ∀x∈S ( A ) : bool
				Which means:
				| Given x∈S:
				|   A : bool.
				|−−−−−−−−−−−−−−−−−−−−
				| ∀x∈S ( A ) : bool.
				
				Note that we use a colon after each header and the full-stop after each statement, because we would want to allow breaking up a statement over multiple lines without ambiguity.
			Now to define what (boolean) statements are valid in a given context.
			To make things easier I shall write "A,...,B : bool" to mean "A,...,B are boolean statements".
			In any context, we have the following syntax rules:
			A : bool ⊢ ¬A : bool 
			A,B : bool ⊢ A∧B : bool 
			A,B : bool ⊢ A∨B : bool 
			A,B : bool ⊢ A⇒B : bool 
			A,B : bool ⊢ A⇔B : bool
			( Given x∈S ⊢ A : bool ) ⊢ ∀x∈S ( A ) : bool 
			( Given x∈S ⊢ A : bool ) ⊢ ∃x∈S ( A ) : bool
			[v is a used variable] ⊢ v : term 
			t[1],...,t[k] : term ; [f is a k-input function-symbol] ⊢ f(t[1],...,t[k]) : term 
			t[1],...,t[k] : term ; [Q is a k-input predicate-symbol] ⊢ Q(t[1],...,t[k]) : bool
			Here a rule of the form "... ⊢ ..." means from the left-hand stuff you can deduce the right-hand stuff (in the current context), and if you have "( ... ⊢ ... )" in the left-hand stuff it means that you have deduced that kind of subcontext previously. For example we can literally do the following deduction if Q is a 1-input predicate symbol:
			Given x∈S:
			Q(x) : bool
			∀x∈S ( Q(x) ) : bool
			All these deductions should never be written out explicitly, but it should be how you think of the syntax rules if you want to be precise. Note that the ∀sub rule ensures you cannot have nested quantification of the same variable. For example you cannot do:
			Given x∈S:
			Given x∈T:  [forbidden!]
					Q(x) : bool
			∃x∈T ( Q(x) ) : bool
			∀x∈S ( ∃x∈T ( Q(x) ) ) : bool
			I've also included the recursive definition of terms in the above rules, just to let you see how one can think of them. For instance, if we have the binary operation + we can actually do the following deduction:
			Given x,y,z∈ℕ:
			x,y,z : term
			x+y : term
			(x+y)+z : term
			Of course, please don't concern yourself now with the actual syntax of binary operations, whether infix or prefix. We do not want to have to write "+(+(x,y),z)" just to make it fit the above rules completely!
			Just understand the structural idea.
			The above rules suffice for plain FOL. For my version of many-sorted FOL, we just need one more:
			( Given x∈S ⊢ x∈S : bool ).
			Oh I forgot, you also need syntax rules for equality:
			t,u : term ⊢ t=u : bool
	Syntax properties:
			Given x,y,z∈S:
				y : term  [since x is a used variable]
				? : ?term
				? = y : ?bool
			Here "?term" is used to indicate that it is a term that may have blanks, and same for "?bool". The rules for "?term" and "?bool" are identical to the rules for sentences except that you change every ": term" and every ": bool" to ": ?term" and ": ?bool" respectively, and you add:
			? : ?term
			Then a property is exactly all those things that you can deduce in front of ": ?bool".
	Example 1:
		Given x∈S:
			Given x∈T:  [forbidden!]
				Q(x) : bool
			∃x∈T ( Q(x) ) : bool
		∀x∈S ( ∃x∈T ( Q(x) ) ) : bool
	Example 2:
		Given k∈ℕ:
			?,k : ?term
			? > k : ?bool
			Given d,x∈ℕ:
				1,d,? : ?term
				d·x : ?term
				1 < d , d < ? , ? = d·x : ?bool
				1 < d < ? ∧ ? = d·x : ?bool
			∃d,x∈ℕ ( 1 < d < ? ∧ ? = d·x ) : ?bool
			¬∃d,x∈ℕ ( 1 < d < ? ∧ ? = d·x ) : ?bool
			? > k ∧ ¬∃d,x∈ℕ ( 1 < d < ? ∧ ? = d·x ) : ?bool
	Useful short-forms:
		"Given x∈S such that Q(x):", expands to:
		Given x∈S:
			If Q(x):
				...
Axioms:
	Division axiom:
		Conventionally, ordered fields are axiomatized without the division operation, and with the axiom "∀x∈ℚ ( x≠0 ⇒ ∃y∈ℚ ( x·y=1 ) )" instead of this axiom. But with the conventional axiomatization, division is definable because we can define the type ℝ[≠0] = { x : x∈ℝ ∧ x≠0 } and use the theorem ∀x∈ℝ ∀y∈ℝ[≠0] !∃z∈ℝ ( x = y·z ) and apply the symbol-defining rule to get ∀x∈ℝ ∀y∈ℝ[≠0] ( x = y·(x/y) ).
		And conversely, with our axiomatization, we can prove ∀x∈ℚ ( x≠0 ⇒ ∃y∈ℚ ( x·y=1 ) ). So both alternatives are essentially equivalent. The advantage of our axiomatization is that it is much easier to use (because it has no ∃-quantifiers). The advantage of the conventional one is that it does not require quantifiers over different types (because we don't have a division-by-zero issue).
	- The ordered field axioms for ℝ imply the same for ℚ because they are all purely universal — purely universal means not just having only ∀-quantifiers, but also that those quantifiers are outside.